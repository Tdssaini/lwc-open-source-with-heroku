"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = exports.JasmineAdapter = exports.default = void 0;

var _jasmine = _interopRequireDefault(require("jasmine"));

var _utils = require("@wdio/utils");

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _reporter = _interopRequireDefault(require("./reporter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const INTERFACES = {
  bdd: ['beforeAll', 'beforeEach', 'it', 'xit', 'fit', 'afterEach', 'afterAll']
};
const TEST_INTERFACES = ['it', 'fit', 'xit'];

const NOOP = function noop() {};

const DEFAULT_TIMEOUT_INTERVAL = 60000;
const log = (0, _logger.default)('@wdio/jasmine-framework');

class JasmineAdapter {
  constructor(cid, config, specs, capabilities, reporter) {
    this.cid = cid;
    this.config = config;
    this.capabilities = capabilities;
    this.specs = specs;
    this.jrunner = {};
    this.totalTests = 0;
    this.jasmineNodeOpts = Object.assign({
      cleanStack: true
    }, config.jasmineNodeOpts);
    this.reporter = new _reporter.default(reporter, {
      cid: this.cid,
      capabilities: this.capabilities,
      specs: this.specs,
      cleanStack: this.jasmineNodeOpts.cleanStack
    });
    this._hasTests = true;
  }

  async init() {
    const self = this;
    this.jrunner = new _jasmine.default();
    const {
      jasmine
    } = this.jrunner;
    const jasmineEnv = jasmine.getEnv();
    this.jrunner.projectBaseDir = '';
    this.jrunner.specDir = '';
    this.jrunner.addSpecFiles(this.specs);
    jasmine.DEFAULT_TIMEOUT_INTERVAL = this.jasmineNodeOpts.defaultTimeoutInterval || DEFAULT_TIMEOUT_INTERVAL;
    jasmineEnv.addReporter(this.reporter);
    const stopOnSpecFailure = !!this.jasmineNodeOpts.stopOnSpecFailure;
    const stopSpecOnExpectationFailure = !!this.jasmineNodeOpts.stopSpecOnExpectationFailure;
    jasmineEnv.configure({
      specFilter: this.customSpecFilter.bind(this),
      stopOnSpecFailure: stopOnSpecFailure,
      random: Boolean(this.jasmineNodeOpts.random),
      oneFailurePerSpec: stopSpecOnExpectationFailure,
      failFast: this.jasmineNodeOpts.failFast
    });
    jasmine.Spec.prototype.addExpectationResult = this.getExpectationResultHandler(jasmine);

    const hookArgsFn = context => [_objectSpread({}, self.lastTest || {}), context];

    const emitHookEvent = (fnName, eventType) => (_test, _context, {
      error
    } = {}) => {
      const title = `"${fnName === 'beforeAll' ? 'before' : 'after'} all" hook`;
      const suiteUid = this.reporter.startedSuite ? this.reporter.getUniqueIdentifier(this.reporter.startedSuite) : `root${this.cid}`;
      const hook = {
        type: 'hook',
        description: title,
        fullName: title,
        uid: `${suiteUid}-${fnName}`,
        error: error ? {
          message: error.message
        } : undefined
      };
      this.reporter.emit('hook:' + eventType, hook);
    };

    INTERFACES['bdd'].forEach(fnName => {
      const isTest = TEST_INTERFACES.includes(fnName);
      const beforeHook = [...this.config.beforeHook];
      const afterHook = [...this.config.afterHook];

      if (fnName.includes('All')) {
        beforeHook.push(emitHookEvent(fnName, 'start'));
        afterHook.push(emitHookEvent(fnName, 'end'));
      }

      (0, _utils.runTestInFiberContext)(isTest, isTest ? this.config.beforeTest : beforeHook, hookArgsFn, isTest ? this.config.afterTest : afterHook, hookArgsFn, fnName, this.cid);
    });
    _jasmine.default.prototype.configureDefaultReporter = NOOP;
    let beforeAllMock = jasmine.Suite.prototype.beforeAll;

    jasmine.Suite.prototype.beforeAll = function (...args) {
      self.lastSpec = this.result;
      beforeAllMock.apply(this, args);
    };

    let executeMock = jasmine.Spec.prototype.execute;

    jasmine.Spec.prototype.execute = function (...args) {
      self.lastTest = this.result;
      self.lastTest.start = new Date().getTime();
      executeMock.apply(this, args);
    };

    this._loadFiles();

    return this;
  }

  _loadFiles() {
    if (this.config.featureFlags.specFiltering !== true) {
      return false;
    }

    try {
      if (Array.isArray(this.jasmineNodeOpts.requires)) {
        this.jrunner.addRequires(this.jasmineNodeOpts.requires);
      }

      if (Array.isArray(this.jasmineNodeOpts.helpers)) {
        this.jrunner.addHelperFiles(this.jasmineNodeOpts.helpers);
      }

      this.jrunner.loadRequires();
      this.jrunner.loadHelpers();
      this.jrunner.loadSpecs();

      this._grep(this.jrunner.env.topSuite());

      this._hasTests = this.totalTests > 0;
    } catch (err) {
      log.warn('Unable to load spec files quite likely because they rely on `browser` object that is not fully initialised.\n' + '`browser` object has only `capabilities` and some flags like `isMobile`.\n' + 'Helper files that use other `browser` commands have to be moved to `before` hook.\n' + `Spec file(s): ${this.specs.join(',')}\n`, 'Error: ', err);
    }
  }

  _grep(suite) {
    suite.children.forEach(child => {
      if (Array.isArray(child.children)) {
        return this._grep(child);
      }

      if (this.customSpecFilter(child)) {
        this.totalTests++;
      }
    });
  }

  hasTests() {
    return this.config.featureFlags.specFiltering !== true || this._hasTests;
  }

  async run() {
    const result = await new Promise(resolve => {
      this.jrunner.env.beforeAll(this.wrapHook('beforeSuite'));
      this.jrunner.env.afterAll(this.wrapHook('afterSuite'));
      this.jrunner.onComplete(() => resolve(this.reporter.getFailedCount()));
      this.jrunner.execute();
    });
    await (0, _utils.executeHooksWithArgs)(this.config.after, [result, this.capabilities, this.specs]);
    return result;
  }

  customSpecFilter(spec) {
    const {
      grep,
      invertGrep
    } = this.jasmineNodeOpts;
    const grepMatch = !grep || spec.getFullName().match(new RegExp(grep)) !== null;

    if (grepMatch === Boolean(invertGrep)) {
      spec.pend('grep');
      return false;
    }

    return true;
  }

  wrapHook(hookName) {
    return done => (0, _utils.executeHooksWithArgs)(this.config[hookName], this.prepareMessage(hookName)).then(() => done(), e => {
      log.info(`Error in ${hookName} hook: ${e.stack.slice(7)}`);
      done();
    });
  }

  prepareMessage(hookName) {
    const params = {
      type: hookName
    };

    switch (hookName) {
      case 'beforeSuite':
      case 'afterSuite':
        params.payload = Object.assign({
          file: this.jrunner.specFiles[0]
        }, this.lastSpec);
        break;

      case 'beforeTest':
      case 'afterTest':
        params.payload = Object.assign({
          file: this.jrunner.specFiles[0]
        }, this.lastTest);
        break;
    }

    return this.formatMessage(params);
  }

  formatMessage(params) {
    let message = {
      type: params.type
    };

    if (params.payload) {
      message.title = params.payload.description;
      message.fullName = params.payload.fullName || null;
      message.file = params.payload.file;

      if (params.payload.failedExpectations && params.payload.failedExpectations.length) {
        message.errors = params.payload.failedExpectations;
        message.error = params.payload.failedExpectations[0];
      }

      if (params.payload.id && params.payload.id.startsWith('spec')) {
        message.parent = this.lastSpec.description;
        message.passed = params.payload.failedExpectations.length === 0;
      }

      if (params.type === 'afterTest') {
        message.duration = new Date().getTime() - params.payload.start;
      }

      if (typeof params.payload.duration === 'number') {
        message.duration = params.payload.duration;
      }
    }

    return message;
  }

  getExpectationResultHandler(jasmine) {
    let {
      expectationResultHandler
    } = this.jasmineNodeOpts;
    const origHandler = jasmine.Spec.prototype.addExpectationResult;

    if (typeof expectationResultHandler !== 'function') {
      return origHandler;
    }

    return this.expectationResultHandler(origHandler);
  }

  expectationResultHandler(origHandler) {
    const {
      expectationResultHandler
    } = this.jasmineNodeOpts;
    return function (passed, data) {
      try {
        expectationResultHandler.call(this, passed, data);
      } catch (e) {
        if (passed) {
          passed = false;
          data = {
            passed: false,
            message: 'expectationResultHandlerError: ' + e.message,
            error: e
          };
        }
      }

      return origHandler.call(this, passed, data);
    };
  }

}

exports.JasmineAdapter = JasmineAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;

adapterFactory.init = async function (...args) {
  const adapter = new JasmineAdapter(...args);
  const instance = await adapter.init();
  return instance;
};

var _default = adapterFactory;
exports.default = _default;