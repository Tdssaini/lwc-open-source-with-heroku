"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const fs = require("fs");
const path = require("path");
const rimraf = require("rimraf");
const webpack = require("webpack");
const lwcConfig_1 = require("../config/lwcConfig");
const webpack_config_1 = require("../config/webpack.config");
const build_1 = require("../messages/build");
const logger_1 = require("../utils/logger");
const statsAnalyzer_1 = require("../utils/webpack/statsAnalyzer");
function buildWebpack(webpackConfig) {
    return new Promise((resolve, reject) => {
        webpack(webpackConfig, (err, stats) => {
            if (err) {
                reject(err);
            }
            if (!stats || !stats.compilation) {
                logger_1.log(build_1.messages.errors.no_compilation);
            }
            // Parsing out error messages during compilation. Makes life MUCH easier.
            const { errors } = stats.compilation;
            if (errors.length) {
                let errorMessages = '';
                errors.forEach((error) => {
                    errorMessages = errorMessages
                        .concat(error.message)
                        .concat('\n');
                });
                return reject(errorMessages);
            }
            statsAnalyzer_1.analyzeStats(stats);
            return resolve();
        });
    });
}
class Build extends command_1.Command {
    async run() {
        const { flags } = this.parse(Build);
        // eslint-disable-next-line no-console
        console.clear();
        logger_1.welcome();
        // For now we use SOURCE_DIR_DEFAULT, may become a dedicated input parameter at a later point in time
        const SOURCE_DIR = lwcConfig_1.lwcConfig.sourceDir;
        // Defining the destination directory
        const BUILD_DIR = lwcConfig_1.lwcConfig.buildDir;
        // Check if given source directory exists. If not we're exiting.
        if (!fs.existsSync(SOURCE_DIR)) {
            logger_1.log(build_1.messages.errors.no_source_dir, SOURCE_DIR);
            return;
        }
        // Clearing build directory, if the user didn't override.
        if (!flags.noclear) {
            if (fs.existsSync(BUILD_DIR)) {
                rimraf.sync(BUILD_DIR);
                logger_1.log(build_1.messages.logs.clear);
            }
        }
        // Check if custom webpack config is passed, and if it really exists.
        if (flags.webpack) {
            if (!fs.existsSync(flags.webpack)) {
                logger_1.log(build_1.messages.errors.no_webpack);
                return;
            }
        }
        logger_1.log(build_1.messages.logs.creating_build_configuration);
        let webpackConfigCustom;
        if (flags.webpack) {
            logger_1.log(build_1.messages.logs.custom_configuration);
            webpackConfigCustom = require(path.resolve(process.cwd(), flags.webpack));
        }
        const webpackConfig = webpack_config_1.generateWebpackConfig(flags.mode, webpackConfigCustom);
        logger_1.log(build_1.messages.logs.build_start);
        if (flags.mode && flags.mode !== lwcConfig_1.lwcConfig.mode) {
            webpackConfig.mode = flags.mode;
        }
        if (flags.destination && flags.destination !== lwcConfig_1.lwcConfig.buildDir) {
            webpackConfig.output.path = path.resolve(process.cwd(), flags.destination);
        }
        try {
            await buildWebpack(webpackConfig);
            logger_1.log(build_1.messages.logs.build_end);
        }
        catch (error) {
            logger_1.log({ message: error, emoji: 'sos' });
            process.exit(1);
        }
    }
}
exports.default = Build;
Build.description = build_1.messages.description;
Build.examples = build_1.messages.help.examples;
Build.flags = {
    help: command_1.flags.help({ char: 'h' }),
    destination: command_1.flags.string({
        char: 'd',
        description: build_1.messages.flags.destination,
        default: lwcConfig_1.lwcConfig.buildDir
    }),
    mode: command_1.flags.string({
        char: 'm',
        description: build_1.messages.flags.mode,
        default: lwcConfig_1.lwcConfig.mode
    }),
    noclear: command_1.flags.boolean({
        char: 'n',
        description: build_1.messages.flags.noclear,
        default: lwcConfig_1.lwcConfig.noclear
    }),
    webpack: command_1.flags.string({
        char: 'w',
        description: build_1.messages.flags.webpack
    })
};
