/* proxy-compat-disable */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Proxy = factory());
}(this, function () { 'use strict';

    function __extends(d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var _a = Object, getOwnPropertyNames = _a.getOwnPropertyNames, create = _a.create, keys = _a.keys, getOwnPropertyDescriptor = _a.getOwnPropertyDescriptor, preventExtensions = _a.preventExtensions, defineProperty = _a.defineProperty, hasOwnProperty = _a.hasOwnProperty, isExtensible = _a.isExtensible, getPrototypeOf = _a.getPrototypeOf, setPrototypeOf = _a.setPrototypeOf;
    var _b = Array.prototype, ArraySlice = _b.slice, ArrayShift = _b.shift, ArrayUnshift = _b.unshift, ArrayConcat = _b.concat;
    var isArray = Array.isArray;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isUndefined(value) {
        return value === undefined;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getOwnPropertyDescriptor$1(replicaOrAny, key) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.getOwnPropertyDescriptor(key);
        }
        return getOwnPropertyDescriptor(replicaOrAny, key);
    }
    function getOwnPropertyNames$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.ownKeys().filter(function (key) { return key.constructor !== Symbol; }); // TODO: only strings
        }
        return getOwnPropertyNames(replicaOrAny);
    }
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys
    // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
    function OwnPropertyKeys(O) {
        return ArrayConcat.call(Object.getOwnPropertyNames(O), Object.getOwnPropertySymbols(O));
    }
    function assign(replicaOrAny) {
        if (replicaOrAny == null) { // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(replicaOrAny);
        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];
            if (nextSource != null) { // Skip over if undefined or null
                var objectKeys = OwnPropertyKeys(nextSource);
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < objectKeys.length; i += 1) {
                    var nextKey = objectKeys[i];
                    var descriptor = getOwnPropertyDescriptor$1(nextSource, nextKey);
                    if (descriptor !== undefined && descriptor.enumerable === true) {
                        setKey(to, nextKey, getKey(nextSource, nextKey));
                    }
                }
            }
        }
        return to;
    }
    function hasOwnProperty$1(key) {
        if (isCompatProxy(this)) {
            var descriptor = this.getOwnPropertyDescriptor(key);
            return !isUndefined(descriptor);
        }
        else {
            return hasOwnProperty.call(this, key);
        }
    }
    function keys$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            var all = replicaOrAny.forIn();
            var result = [];
            // tslint:disable-next-line:forin
            for (var prop in all) {
                var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
                if (desc && desc.enumerable === true) {
                    result.push(prop);
                }
            }
            return result;
        }
        else {
            return keys(replicaOrAny);
        }
    }
    function values(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            var all = replicaOrAny.forIn();
            var result = [];
            // tslint:disable-next-line:forin
            for (var prop in all) {
                var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
                if (desc && desc.enumerable === true) {
                    result.push(getKey(replicaOrAny, prop));
                }
            }
            return result;
        }
        else {
            // Calling `Object.values` instead of dereferencing the method during the module evaluation
            // since `Object.values` gets polyfilled at the module evaluation.
            return Object.values(replicaOrAny);
        }
    }
    function entries(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            var all = replicaOrAny.forIn();
            var result = [];
            // tslint:disable-next-line:forin
            for (var prop in all) {
                var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
                if (desc && desc.enumerable === true) {
                    result.push([
                        prop,
                        getKey(replicaOrAny, prop)
                    ]);
                }
            }
            return result;
        }
        else {
            // Calling `Object.entries` instead of dereferencing the method during the module evaluation
            // since `Object.entries` gets polyfilled at the module evaluation.
            return Object.entries(replicaOrAny);
        }
    }
    function defineProperty$1(replicaOrAny, prop, descriptor) {
        if (isCompatProxy(replicaOrAny)) {
            replicaOrAny.defineProperty(prop, descriptor);
            return replicaOrAny;
        }
        else {
            return defineProperty(replicaOrAny, prop, descriptor);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ProxyTypeObject = 1;
    var ProxyTypeArray = 2;
    // Proto chain check might be needed because of usage of a limited polyfill
    // https://github.com/es-shims/get-own-property-symbols
    // In this case, because this polyfill is assing all the stuff to Object.prototype to keep
    // all the other invariants of Symbols, we need to do some manual checks here for the slow patch.
    var isNotNativeSymbol;
    var inOperator = function inOperatorCompat(obj, key) {
        if (isNotNativeSymbol === undefined) {
            if (typeof Symbol === 'undefined') {
                throw new Error('Symbol is not available. Make sure to apply symbol polyfill before calling inOperator');
            }
            isNotNativeSymbol = typeof Symbol() === 'object';
        }
        if (isNotNativeSymbol) {
            var getOwnPropertySymbols = Object.getOwnPropertySymbols;
            if (key && key.constructor === Symbol) {
                while (obj) {
                    if (getOwnPropertySymbols(obj).indexOf(key) !== -1) {
                        return true;
                    }
                    obj = getPrototypeOf(obj);
                }
                return false;
            }
            return key in obj;
        }
        return key in obj;
    };
    var defaultHandlerTraps = {
        get: function (target, key) {
            return target[key];
        },
        set: function (target, key, newValue) {
            target[key] = newValue;
            return true;
        },
        apply: function (targetFn, thisArg, argumentsList) {
            return targetFn.apply(thisArg, argumentsList);
        },
        construct: function (targetFn, argumentsList, newTarget) {
            return new (targetFn.bind.apply(targetFn, [void 0].concat(argumentsList)))();
        },
        defineProperty: function (target, property, descriptor) {
            defineProperty(target, property, descriptor);
            return true;
        },
        deleteProperty: function (target, property) {
            return delete target[property];
        },
        ownKeys: function (target) {
            return OwnPropertyKeys(target);
        },
        has: function (target, propertyKey) {
            return inOperator(target, propertyKey);
        },
        preventExtensions: function (target) {
            preventExtensions(target);
            return true;
        },
        getOwnPropertyDescriptor: getOwnPropertyDescriptor,
        getPrototypeOf: getPrototypeOf,
        isExtensible: isExtensible,
        setPrototypeOf: setPrototypeOf,
    };
    var lastRevokeFn;
    var proxyTrapFalsyErrors = {
        set: function (target, key) {
            throw new TypeError("'set' on proxy: trap returned falsish for property '" + key + "'");
        },
        deleteProperty: function (target, key) {
            throw new TypeError("'deleteProperty' on proxy: trap returned falsish for property '" + key + "'");
        },
        setPrototypeOf: function (target, proto) {
            throw new TypeError("'setPrototypeOf' on proxy: trap returned falsish");
        },
        preventExtensions: function (target, proto) {
            throw new TypeError("'preventExtensions' on proxy: trap returned falsish");
        },
        defineProperty: function (target, key, descriptor) {
            throw new TypeError("'defineProperty' on proxy: trap returned falsish for property '" + key + "'");
        }
    };
    function proxifyProperty(proxy, key, descriptor) {
        var enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        defineProperty(proxy, key, {
            enumerable: enumerable,
            configurable: configurable,
            get: function () {
                return proxy.get(key);
            },
            set: function (value) {
                proxy.set(key, value);
            },
        });
    }
    var XProxy = /** @class */ (function () {
        function XProxy(target, handler) {
            var targetIsFunction = typeof target === 'function';
            var targetIsArray = isArray(target);
            if ((typeof target !== 'object' || target === null) && !targetIsFunction) {
                throw new Error("Cannot create proxy with a non-object as target");
            }
            if (typeof handler !== 'object' || handler === null) {
                throw new Error("new XProxy() expects the second argument to an object");
            }
            // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.
            // The caller might get the wrong revoke function if a user replaces or wraps XProxy
            // to call itself, but that seems unlikely especially when using the polyfill.
            var throwRevoked = false;
            lastRevokeFn = function () {
                throwRevoked = true;
            };
            // Define proxy as Object, or Function (if either it's callable, or apply is set).
            // tslint:disable-next-line:no-this-assignment
            var proxy = this; // reusing the already created object, eventually the prototype will be resetted
            if (targetIsFunction) {
                proxy = function Proxy() {
                    var usingNew = (this && this.constructor === proxy);
                    var args = ArraySlice.call(arguments);
                    if (usingNew) {
                        return proxy.construct(args, this);
                    }
                    else {
                        return proxy.apply(this, args);
                    }
                };
            }
            var _loop_1 = function (trapName) {
                defineProperty(proxy, trapName, {
                    value: function () {
                        if (throwRevoked) {
                            throw new TypeError("Cannot perform '" + trapName + "' on a proxy that has been revoked");
                        }
                        var args = ArraySlice.call(arguments);
                        ArrayUnshift.call(args, target);
                        var h = handler[trapName] ? handler : defaultHandlerTraps;
                        var value = h[trapName].apply(h, args);
                        if (proxyTrapFalsyErrors[trapName] && value === false) {
                            proxyTrapFalsyErrors[trapName].apply(proxyTrapFalsyErrors, args);
                        }
                        return value;
                    },
                    writable: false,
                    enumerable: false,
                    configurable: false,
                });
            };
            // tslint:disable-next-line:forin
            for (var trapName in defaultHandlerTraps) {
                _loop_1(trapName);
            }
            var proxyDefaultHasInstance;
            var SymbolHasInstance = Symbol.hasInstance;
            var FunctionPrototypeSymbolHasInstance = Function.prototype[SymbolHasInstance];
            defineProperty(proxy, SymbolHasInstance, {
                get: function () {
                    var hasInstance = proxy.get(SymbolHasInstance);
                    // We do not want to deal with any Symbol.hasInstance here
                    // because we need to do special things to check prototypes.
                    // Symbol polyfill adds Symbol.hasInstance to the function prototype
                    // so if we have that here, we need to return our own.
                    // If the value we get from this function is different, that means
                    // user has supplied custom function so we need to respect that.
                    if (hasInstance === FunctionPrototypeSymbolHasInstance) {
                        return proxyDefaultHasInstance || (proxyDefaultHasInstance = function (inst) {
                            return defaultHasInstance(inst, proxy);
                        });
                    }
                    return hasInstance;
                },
                configurable: false,
                enumerable: false
            });
            defineProperty(proxy, '_ES5ProxyType', {
                value: targetIsArray ? ProxyTypeArray : ProxyTypeObject,
                configurable: false,
                enumerable: false,
                writable: true,
            });
            defineProperty(proxy, 'forIn', {
                value: function () {
                    return proxy.ownKeys().reduce(function (o, key) {
                        o[key] = void 0;
                        return o;
                    }, create(null));
                },
                configurable: false,
                enumerable: false,
                writable: false,
            });
            var SymbolIterator = Symbol.iterator;
            defineProperty(proxy, SymbolIterator, {
                enumerable: false,
                configurable: true,
                get: function () {
                    return this.get(SymbolIterator);
                },
                set: function (value) {
                    this.set(SymbolIterator, value);
                },
            });
            if (targetIsArray) {
                var trackedLength_1 = 0;
                var adjustArrayIndex_1 = function (newLength) {
                    // removing old indexes from proxy when needed
                    while (trackedLength_1 > newLength) {
                        delete proxy[--trackedLength_1];
                    }
                    // add new indexes to proxy when needed
                    for (var i = trackedLength_1; i < newLength; i += 1) {
                        proxifyProperty(proxy, i, {
                            enumerable: true,
                            configurable: true,
                        });
                    }
                    trackedLength_1 = newLength;
                };
                defineProperty(proxy, 'length', {
                    enumerable: false,
                    configurable: true,
                    get: function () {
                        var proxyLength = proxy.get('length');
                        // check if the trackedLength matches the length of the proxy
                        if (proxyLength !== trackedLength_1) {
                            adjustArrayIndex_1(proxyLength);
                        }
                        return proxyLength;
                    },
                    set: function (value) {
                        proxy.set('length', value);
                    },
                });
                // building the initial index. this is observable by the proxy
                // because we access the length property during the construction
                // of the proxy, but it should be fine...
                adjustArrayIndex_1(proxy.get('length'));
            }
            return proxy;
        }
        // tslint:disable-next-line:member-ordering
        XProxy.revocable = function (target, handler) {
            var p = new XProxy(target, handler);
            return {
                proxy: p,
                revoke: lastRevokeFn,
            };
        };
        XProxy.prototype.push = function () {
            var push$1 = this.get('push');
            if (push$1 === Array.prototype.push) {
                push$1 = push;
            }
            return push$1.apply(this, arguments);
        };
        XProxy.prototype.pop = function () {
            var pop$1 = this.get('pop');
            if (pop$1 === Array.prototype.pop) {
                pop$1 = pop;
            }
            return pop$1.apply(this, arguments);
        };
        XProxy.prototype.concat = function () {
            var concat = this.get('concat');
            if (concat === Array.prototype.concat) {
                concat = concat$1;
            }
            return concat.apply(this, arguments);
        };
        XProxy.prototype.splice = function () {
            var splice$1 = this.get('splice');
            if (splice$1 === Array.prototype.splice) {
                splice$1 = splice;
            }
            return splice$1.apply(this, arguments);
        };
        XProxy.prototype.shift = function () {
            var shift$1 = this.get('shift');
            if (shift$1 === Array.prototype.shift) {
                shift$1 = shift;
            }
            return shift$1.apply(this, arguments);
        };
        XProxy.prototype.unshift = function () {
            var unshift$1 = this.get('unshift');
            if (unshift$1 === Array.prototype.unshift) {
                unshift$1 = unshift;
            }
            return unshift$1.apply(this, arguments);
        };
        XProxy.prototype.toJSON = function () {
            if (this._ES5ProxyType === ProxyTypeArray) {
                var unwrappedArray = [];
                var length = this.get('length');
                for (var i = 0; i < length; i++) {
                    unwrappedArray[i] = this.get(i);
                }
                return unwrappedArray;
            }
            else {
                var toJSON = this.get('toJSON');
                if (toJSON !== undefined && typeof toJSON === 'function') {
                    return toJSON.apply(this, arguments);
                }
                var keys = this.ownKeys();
                var unwrappedObject = {};
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var enumerable = this.getOwnPropertyDescriptor(key).enumerable;
                    if (enumerable) {
                        unwrappedObject[key] = this.get(key);
                    }
                }
                return unwrappedObject;
            }
        };
        return XProxy;
    }());

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function defaultHasInstance(instance, Type) {
        // We have to grab getPrototypeOf here
        // because caching it at the module level is too early.
        // We need our shimmed version.
        var getPrototypeOf = Object.getPrototypeOf;
        var instanceProto = getPrototypeOf(instance);
        var TypeProto = getKey(Type, 'prototype');
        while (instanceProto !== null) {
            if (instanceProto === TypeProto) {
                return true;
            }
            instanceProto = getPrototypeOf(instanceProto);
        }
        return false;
    }
    // NOTE: For performance reasons, the "_ES5ProxyType" key should be checked without
    // using this function, unless `replicaOrAny._ES5ProxyType` might throw unexpectedly.
    function isCompatProxy(replicaOrAny) {
        return replicaOrAny && replicaOrAny._ES5ProxyType;
    }
    var getKey = function (replicaOrAny, k1) {
        return replicaOrAny._ES5ProxyType ?
            replicaOrAny.get(k1) :
            replicaOrAny[k1];
    };
    var getKeys2 = function (replicaOrAny, k1, k2) {
        var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
        return replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
    };
    var getKeys3 = function (replicaOrAny, k1, k2, k3) {
        var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
        var replicaOrAny2 = replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
        return replicaOrAny2._ES5ProxyType ? replicaOrAny2.get(k3) : replicaOrAny2[k3];
    };
    var getKeys4 = function (replicaOrAny, k1, k2, k3, k4) {
        var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
        var replicaOrAny2 = replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
        var replicaOrAny3 = replicaOrAny2._ES5ProxyType ? replicaOrAny2.get(k3) : replicaOrAny2[k3];
        return replicaOrAny3._ES5ProxyType ? replicaOrAny3.get(k4) : replicaOrAny3[k4];
    };
    var getKeys = function (replicaOrAny) {
        var l = arguments.length;
        for (var i = 1; i < l; i++) {
            var key = arguments[i];
            replicaOrAny = replicaOrAny._ES5ProxyType ? replicaOrAny.get(key) : replicaOrAny[key];
        }
        return replicaOrAny;
    };
    var callKey0 = function (replicaOrAny, key) {
        return getKey(replicaOrAny, key).call(replicaOrAny);
    };
    var callKey1 = function (replicaOrAny, key, a1) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1);
    };
    var callKey2 = function (replicaOrAny, key, a1, a2) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2);
    };
    var callKey3 = function (replicaOrAny, key, a1, a2, a3) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2, a3);
    };
    var callKey4 = function (replicaOrAny, key, a1, a2, a3, a4) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2, a3, a4);
    };
    var callKey = function (replicaOrAny, key) {
        var fn = getKey(replicaOrAny, key);
        var l = arguments.length;
        var args = [];
        for (var i = 2; i < l; i++) {
            args[i - 2] = arguments[i];
        }
        return fn.apply(replicaOrAny, args);
    };
    var setKey = function (replicaOrAny, key, newValue) {
        return replicaOrAny._ES5ProxyType ?
            replicaOrAny.set(key, newValue) :
            replicaOrAny[key] = newValue;
    };
    var setKeyPostfixIncrement = function (replicaOrAny, key) {
        var originalValue = getKey(replicaOrAny, key);
        setKey(replicaOrAny, key, originalValue + 1);
        return originalValue;
    };
    var setKeyPostfixDecrement = function (replicaOrAny, key) {
        var originalValue = getKey(replicaOrAny, key);
        setKey(replicaOrAny, key, originalValue - 1);
        return originalValue;
    };
    var deleteKey = function (replicaOrAny, key) {
        if (replicaOrAny._ES5ProxyType) {
            return replicaOrAny.deleteProperty(key);
        }
        delete replicaOrAny[key];
    };
    var inKey = function (replicaOrAny, key) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.has(key);
        }
        return inOperator(replicaOrAny, key);
    };
    var iterableKey = function (replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.forIn();
        }
        return replicaOrAny;
    };
    function instanceOfKey(instance, Type) {
        var instanceIsCompatProxy = isCompatProxy(instance);
        if (!isCompatProxy(Type) && !instanceIsCompatProxy) {
            return instance instanceof Type;
        }
        // TODO: Once polyfills are transpiled to compat
        // We can probably remove the below check
        if (instanceIsCompatProxy) {
            return defaultHasInstance(instance, Type);
        }
        return Type[Symbol.hasInstance](instance);
    }
    function concat(replicaOrAny) {
        var fn = getKey(replicaOrAny, 'concat');
        if (fn === Array.prototype.concat) {
            fn = concat$1;
        }
        var args = [];
        var l = arguments.length;
        for (var i = 1; i < l; i++) {
            args[i - 1] = arguments[i];
        }
        return fn.apply(replicaOrAny, args);
    }
    function hasOwnProperty$2(replicaOrAny) {
        var fn = getKey(replicaOrAny, 'hasOwnProperty');
        if (fn === hasOwnProperty) {
            fn = hasOwnProperty$1;
        }
        var args = [];
        var l = arguments.length;
        for (var i = 1; i < l; i++) {
            args[i - 1] = arguments[i];
        }
        return fn.apply(replicaOrAny, args);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // https://tc39.github.io/ecma262/#sec-array.isarray
    // Important: The Array.isArray method is not dereferenced. This way it calls the polyfilled
    // version of it, even if the polyfill is applied after the proxy-compat evaluation.
    function isArray$1(replicaOrAny) {
        return isCompatProxy(replicaOrAny) ?
            replicaOrAny._ES5ProxyType === ProxyTypeArray :
            Array.isArray(replicaOrAny);
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.pop
    function pop() {
        // 1. Let O be ? ToObject(this value).
        var O = Object(this);
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = O.length;
        // 3. If len is zero, then
        if (len === 0) {
            // a. Perform ? Set(O, "length", 0, true). noop
            // b. Return undefined.
            return undefined;
            // 4. Else len > 0,
        }
        else if (len > 0) {
            // a. Let newLen be len-1.
            var newLen = len - 1;
            // b. Let index be ! ToString(newLen).
            var index = newLen;
            // c. Let element be ? Get(O, index).
            var element = getKey(O, index);
            // d. Perform ? DeletePropertyOrThrow(O, index).
            deleteKey(O, index);
            // e. Perform ? Set(O, "length", newLen, true).
            setKey(O, 'length', newLen);
            // f. Return element.
            return element;
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.push
    function push() {
        var O = Object(this);
        var n = O.length;
        var items = ArraySlice.call(arguments);
        while (items.length) {
            var E = ArrayShift.call(items);
            setKey(O, n, E);
            n += 1;
        }
        setKey(O, 'length', n);
        return O.length;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.concat
    function concat$1() {
        var O = Object(this);
        var A = [];
        var N = 0;
        var items = ArraySlice.call(arguments);
        ArrayUnshift.call(items, O);
        while (items.length) {
            var E = ArrayShift.call(items);
            if (isArray$1(E)) {
                var k = 0;
                var length = E.length;
                for (k; k < length; k += 1, N += 1) {
                    var subElement = getKey(E, k);
                    A[N] = subElement;
                }
            }
            else {
                A[N] = E;
                N += 1;
            }
        }
        return A;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.shift
    function shift() {
        // 1. Let O be ? ToObject(this value).
        var O = Object(this);
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = O.length;
        // 3. If len is zero, then
        if (len === 0) {
            // a. Perform ? Set(O, "length", 0, true). noop
            // b. Return undefined.
            return undefined;
        }
        // 4. Let first be ? Get(O, "0").
        var first = getKey(O, 0);
        // 5. Let k be 1.
        var k = 1;
        // 6. Repeat, while k < len
        while (k < len) {
            // a. Let from be ! ToString(k).
            var from = k;
            // b. Let to be ! ToString(k-1).
            var to = k - 1;
            // c. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = hasOwnProperty$1.call(O, from);
            // d. If fromPresent is true, then
            if (fromPresent) {
                // i. Let fromVal be ? Get(O, from).
                var fromVal = getKey(O, from);
                // ii. Perform ? Set(O, to, fromVal, true).
                setKey(O, to, fromVal);
            }
            else { // e. Else fromPresent is false,
                // i. Perform ? DeletePropertyOrThrow(O, to).
                deleteKey(O, to);
            }
            // f. Increase k by 1.
            k += 1;
        }
        // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).
        deleteKey(O, len - 1);
        // 8. Perform ? Set(O, "length", len-1, true).
        setKey(O, 'length', len - 1);
        // 9. Return first.
        return first;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.unshift
    function unshift() {
        var O = Object(this);
        var len = O.length;
        var argCount = arguments.length;
        var k = len;
        while (k > 0) {
            var from = k - 1;
            var to = k + argCount - 1;
            var fromPresent = hasOwnProperty$1.call(O, from);
            if (fromPresent) {
                var fromValue = O[from];
                setKey(O, to, fromValue);
            }
            else {
                deleteKey(O, to);
            }
            k -= 1;
        }
        var j = 0;
        var items = ArraySlice.call(arguments);
        while (items.length) {
            var E = ArrayShift.call(items);
            setKey(O, j, E);
            j += 1;
        }
        O.length = len + argCount;
        return O.length;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.splice
    function splice(start, deleteCount) {
        var argLength = arguments.length;
        // 1. Let O be ? ToObject(this value).
        var O = Object(this);
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = O.length;
        // 3. Let relativeStart be ? ToInteger(start).
        var relativeStart = start;
        // 4. If relativeStart < 0, let actualStart be max((len + relativeStart), 0);
        // else let actualStart be min(relativeStart, len).
        var actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        var actualDeleteCount;
        // 5. If the number of actual arguments is 0, then
        if (argLength === 0) {
            // a. Let insertCount be 0.
            // insertCount = 0 // not needed
            // b. Let actualDeleteCount be 0.
            actualDeleteCount = 0;
        }
        else if (argLength === 1) {
            // 6. Else if the number of actual arguments is 1, then
            // a. Let insertCount be 0.
            // insertCount = 0 // not needed
            // b. Let actualDeleteCount be len - actualStart.
            actualDeleteCount = len - actualStart;
        }
        else {
            // 7. Else,
            // a. Let insertCount be the number of actual arguments minus 2.
            // insertCount = argLength - 2; //not neede
            // b. Let dc be ? ToInteger(deleteCount).
            var dc = deleteCount;
            // c. Let actualDeleteCount be min(max(dc, 0), len - actualStart).
            actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
        }
        // 8. If len+insertCount-actualDeleteCount > 2^53-1, throw a TypeError exception
        // (noop)
        // 9. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).
        var A = [];
        // 10. Let k be 0.
        var k = 0;
        // 11. Repeat, while k < actualDeleteCount
        while (k < actualDeleteCount) {
            // a. Let from be ! ToString(actualStart+k).
            var from = actualStart + k;
            // b. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = hasOwnProperty$1.call(O, from);
            // c. If fromPresent is true, then
            if (fromPresent) {
                // i. Let fromValue be ? Get(O, from).
                var fromValue = O[from];
                // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).
                A[k] = fromValue;
            }
            // d. Increment k by 1.
            k++;
        }
        // 12. Perform ? Set(A, "length", actualDeleteCount, true).
        // A.length = actualDeleteCount;
        // 13. Let items be a List whose elements are, in left to right order, the portion of the actual argument
        //     list starting with the third argument. The list is empty if fewer than three arguments were passed.
        var items = ArraySlice.call(arguments, 2) || [];
        // 14. Let itemCount be the number of elements in items.
        var itemCount = items.length;
        // 15. If itemCount < actualDeleteCount, then
        if (itemCount < actualDeleteCount) {
            // a. Let k be actualStart.
            k = actualStart;
            // b. Repeat, while k < (len - actualDeleteCount)
            while (k < len - actualDeleteCount) {
                // i. Let from be ! ToString(k+actualDeleteCount).
                var from = k + actualDeleteCount;
                // ii. Let to be ! ToString(k+itemCount).
                var to = k + itemCount;
                // iii. Let fromPresent be ? HasProperty(O, from).
                var fromPresent = hasOwnProperty$1.call(O, from);
                // iv. If fromPresent is true, then
                if (fromPresent) {
                    // 1. Let fromValue be ? Get(O, from).
                    var fromValue = O[from];
                    // 2. Perform ? Set(O, to, fromValue, true).
                    setKey(O, to, fromValue);
                }
                else {
                    // v. Else fromPresent is false,
                    // 1. Perform ? DeletePropertyOrThrow(O, to).
                    deleteKey(O, to);
                }
                // vi. Increase k by 1.
                k++;
            }
            // c. Let k be len.
            k = len;
            // d. Repeat, while k > (len - actualDeleteCount + itemCount)
            while (k > len - actualDeleteCount + itemCount) {
                // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).
                deleteKey(O, k - 1);
                // ii. Decrease k by 1.
                k--;
            }
        }
        else if (itemCount > actualDeleteCount) {
            // 16. Else if itemCount > actualDeleteCount, then
            // a. Let k be (len - actualDeleteCount).
            k = len - actualDeleteCount;
            // b. Repeat, while k > actualStart
            while (k > actualStart) {
                // i. Let from be ! ToString(k + actualDeleteCount - 1).
                var from = k + actualDeleteCount - 1;
                // ii. Let to be ! ToString(k + itemCount - 1).
                var to = k + itemCount - 1;
                // iii. Let fromPresent be ? HasProperty(O, from).
                var fromPresent = hasOwnProperty$1.call(O, from);
                // iv. If fromPresent is true, then
                if (fromPresent) {
                    // 1. Let fromValue be ? Get(O, from).
                    var fromValue = O[from];
                    // 2. Perform ? Set(O, to, fromValue, true).
                    setKey(O, to, fromValue);
                }
                else {
                    // v. Else fromPresent is false,
                    // 1. Perform ? DeletePropertyOrThrow(O, to).
                    deleteKey(O, to);
                }
                // vi. Decrease k by 1.
                k--;
            }
        }
        // 17. Let k be actualStart.
        k = actualStart;
        // 18. Repeat, while items is not empty
        while (items.length) {
            // a. Remove the first element from items and let E be the value of that element.
            var E = items.shift();
            // b. Perform ? Set(O, ! ToString(k), E, true).
            setKey(O, k, E);
            // c. Increase k by 1.
            k++;
        }
        // 19. Perform ? Set(O, "length", len - actualDeleteCount + itemCount, true).
        setKey(O, 'length', len - actualDeleteCount + itemCount);
        // 20. Return A.
        return A;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getPrototypeOf$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.getPrototypeOf();
        }
        return getPrototypeOf(replicaOrAny);
    }
    function setPrototypeOf$1(replicaOrAny, proto) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.setPrototypeOf(proto);
        }
        return setPrototypeOf(replicaOrAny, proto);
    }
    function preventExtensions$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.preventExtensions();
        }
        return preventExtensions(replicaOrAny);
    }
    function isExtensible$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.isExtensible();
        }
        return isExtensible(replicaOrAny);
    }
    // Object patches
    // TODO: Instead of monkey patching, move all of these to be compatInstrinsicMethods
    // like the ones right below.
    Object.preventExtensions = preventExtensions$1;
    Object.getOwnPropertyNames = getOwnPropertyNames$1;
    Object.isExtensible = isExtensible$1;
    Object.setPrototypeOf = setPrototypeOf$1;
    Object.getPrototypeOf = getPrototypeOf$1;
    // We need to ensure that added compat methods are not-enumerable to avoid leaking
    // when using for ... in without guarding via Object.hasOwnProperty.
    Object.defineProperties(Object, {
        compatKeys: { value: keys$1, enumerable: false },
        compatValues: { value: values, enumerable: false },
        compatEntries: { value: entries, enumerable: false },
        compatDefineProperty: { value: defineProperty$1, enumerable: false },
        compatAssign: { value: assign, enumerable: false },
        compatGetOwnPropertyDescriptor: { value: getOwnPropertyDescriptor$1, enumerable: false }
    });
    Object.defineProperties(Object.prototype, {
        compatHasOwnProperty: { value: hasOwnProperty$1, enumerable: false }
    });
    // Array patches
    Object.defineProperties(Array, {
        compatIsArray: { value: isArray$1, enumerable: false }
    });
    Object.defineProperties(Array.prototype, {
        compatUnshift: { value: unshift, enumerable: false },
        compatConcat: { value: concat$1, enumerable: false },
        compatPush: { value: push, enumerable: false },
    });
    function overrideProxy() {
        return Proxy.__COMPAT__;
    }
    function makeGlobal(obj) {
        var global = (function () { return this; })() || Function('return this')();
        global.Proxy = obj;
    }
    // At this point Proxy can be the real Proxy (function) a noop-proxy (object with noop-keys) or undefined
    var FinalProxy = typeof Proxy !== 'undefined' ? Proxy : {};
    if (typeof FinalProxy !== 'function' || overrideProxy()) {
        FinalProxy = /** @class */ (function (_super) {
            __extends(Proxy, _super);
            function Proxy() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return Proxy;
        }(XProxy));
    }
    FinalProxy.isCompat = true;
    FinalProxy.getKey = getKey;
    FinalProxy.getKeys = getKeys;
    FinalProxy.getKeys2 = getKeys2;
    FinalProxy.getKeys3 = getKeys3;
    FinalProxy.getKeys4 = getKeys4;
    FinalProxy.callKey = callKey;
    FinalProxy.callKey0 = callKey0;
    FinalProxy.callKey1 = callKey1;
    FinalProxy.callKey2 = callKey2;
    FinalProxy.callKey3 = callKey3;
    FinalProxy.callKey4 = callKey4;
    FinalProxy.setKey = setKey;
    FinalProxy.setKeyPostfixIncrement = setKeyPostfixIncrement;
    FinalProxy.setKeyPostfixDecrement = setKeyPostfixDecrement;
    FinalProxy.deleteKey = deleteKey;
    FinalProxy.inKey = inKey;
    FinalProxy.iterableKey = iterableKey;
    FinalProxy.instanceOfKey = instanceOfKey;
    FinalProxy.concat = concat;
    FinalProxy.hasOwnProperty = hasOwnProperty$2;
    if (typeof Proxy === 'undefined') {
        makeGlobal(FinalProxy);
    }
    var FinalProxy$1 = FinalProxy;

    return FinalProxy$1;

}));
